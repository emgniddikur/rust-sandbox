use std::rc::Rc;

// 所有者がドロップされた場合、所有されていた値もドロップされる
// 変数が値を所有する　その変数が宣言されたブロックを制御が離れたとき（スコープから外れるなど）に、変数はドロップされ、値もドロップされる
// 変数が値を所有するのと同じように、構造体はそのフィールドを、タプルや配列やベクタはその要素を所有する
// すべての値に唯一の所有者がいる

// 移動　move
// 値を1つの所有者から別の所有者に移動させることができる　これによって、ツリーを構築し、変更し、分割することができるようになる
// ほとんど全ての型が、変数への値の代入、関数への引数の受け渡し、関数からの返り値の返却、タプルの作成の際にコピーされず、移動される
// 受け渡し元は、値の所有権を受け渡し先に引き渡し、未初期化状態になる
// すでに初期化されている変数に値を移動すると、代入される変数に以前から入っていた値はドロップされる

fn main() {
    let a = vec![0, 1, 2];
    let b = a;
    // let c = a; // value used here after move

    struct Person {
        name: String,
        birth: i32,
    }
    // 所有権がVec::newから移動する
    let mut composers = Vec::<Person>::new();
    // 構造体全体がpushメソッドに渡される　このメソッドが、ベクタの最後にこの構造体を移動させる
    composers.push(Person {
        // 構造体がこの文字列の所有権を持つ
        name: "John Doe".to_string(),
        birth: 2000,
    });

    let mut v = Vec::<String>::new();
    for i in 0..3 {
        v.push(i.to_string());
    }
    // let foo = v[0]; // cannot move out of indexed content

    // ループにベクタを直接渡すと、ベクタは変数から移動され、変数は未初期化状態になる
    // 繰り返しごとに、ループは新たな要素を変数sに移動する
    // ループ内では、そのベクタはコードから見えなくなっている

    // 文字列の代入は値の移動となるが、i32の代入はコピーになる
    // i32はメモリ上の単なるビットパターンで、ヒープ上のリソースを持たない
    // Copy型⋯移動が発生しない型　数値型、char型、bool型、Copy型のタプル、配列
    // 単純なビット単位のコピーだけで事足りる型だけがCopyとなり得る
    // 値をドロップする際に何か特別なことをしなければならない型はCopy型ではない

    // Copyトレイトを実装するとコピーされるようになる
    #[derive(Copy, Clone)]
    struct Label {
        number: u32,
        // name: String, // this field does not implement `Copy`
    }
    fn print(l: Label) {
        println!("{}", l.number);
    }
    let l = Label {
        number: 1,
        // name: "John Doe",
    };
    print(l);
    println!("{}", l.number);

    // ある値を使っている全てのものが使い終わるまで生きていてほしいような場合は、所有者が1つしかない状態だと難しい場合がある　=>　Rc, Arc
    // ・Rc型　reference count　高速だがスレッド安全でないコードで参照カウントを管理する
    // ・Arc型　atomic reference count　複数のスレッド間で直接共有しても安全なようにできている
    // スレッド間でポインタの共有を行うかどうかで使い分ける

    let s: Rc<String> = Rc::new("foo".to_string());
    let t: Rc<String> = s.clone();
    let u: Rc<String> = s.clone();

    // 最後に残ったRcがドロップされると、Tもドロップされる
    // Rcポインタに所有される値は不変となる

    // メモリ安全性とスレッド安全性は、ある値が、共有されていると同時に可変にはならないことに依存している

    // 2つの参照カウントされた値がお互いを参照している場合、お互いがお互いの参照カウントをゼロ以上に保つので、両方とも解放されなくなってしまう
    // 古い値を可変にすることで防ぐことができる
}
